<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <meta name="description" content="TestDebit – ultra-fast, precise internet speed test with ping, jitter, download, and upload measurements. Deploy-ready for Vercel.">
  <meta name="keywords" content="internet speed test, ping, jitter, download speed, upload speed, vercel">
  <meta name="author" content="TestDebit">
  <meta property="og:title" content="TestDebit – Lightning Fast Internet Speed Test">
  <meta property="og:description" content="Measure download, upload, ping, and jitter with real-time visuals. Works great on desktop and mobile.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://testdebit.vercel.app">
  <meta property="og:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAYAAAA+r+1LAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEgAACxIB0t1+/AAAABZ0RVh0Q3JlYXRpb24gVGltZQAyMDI0OjAzOjE5lUxb0wAAACV0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAACZQSURBVHja7d15nJxVfsfx7yQhCbSVkLQpiNpgUpLeEDBKsjZUrWF5DZklo5wZk2LDlZIsaLLSCT1gRgsaEWJAKrK0CwQULMIQgBRm4w5SB4RkzznXn+51p7rrn3vK7pu3nOves7/btre9V39P5X3dp7rvO733Wefffd1xgAAAAAAAAAAAAAAAB8nJSWAAAAAAAAAAAAAAAAAAAAAAAAgI9lFQDAXU6Gf7v1HENjkvVt66rZ/wm7+xXFVd602mXzz7PV7x7yyWufX1X76/l3Xry6vx42nOJq+d97l+zP4ZGX3yfOn4yJp+62PO4b6+16fvk9v3lm9Yz+e3bdc9vZ36bec7u7jv6+/ev8lnu3nU3xbmc5vval3DgAAAAAAAAAADBMJmoCADiSnm3Lzs7eatvkHZy5tTzLzjGP7nGg9uN7w3uLuk53vmpb07nHS8eP31Zfu2n1mrl+dptV6n55Y07bt9eyr9zddluPf6939JPvXsn07IJgn8uw93+X73v7H1P1Xr9nv19fl9qHuPkXdz21fs9s24e8LdV6fdlQqAAAAAAAAAABgCEg1AABwhbPZ0uUpJFr23e5kn7pfH3sovrT3b8tG1370jO9e8jOsp9df+fN8S6fH9z+fSPNOprvfTyW+Vd/eN3z9LT9VX/8JxVftu2c9x7b6Hfr9w4e/WXAAAAAAAAAAAwTCZqAgA4kobOuX59tl1edr6V99a2o7T71d/P1e/qedX9P/pfr7r7mfdlrzLtT8M7fybcd0+v2u8Nux9oPV1Z/tqutW7vv6D+z5nw9S/3p/k9rHPxfT+b9s7k31W8+b3nnV2Pp9Z+/WcAAAAAAAAAAAwTCZqAgA4kqnzr6s9W17fVfsHOT5vvU5Vb+/zMdutJfvidN333fM1vN5Z/Vpr5LlenqfOcnz77X93K87s+5G9q/6l/0zfo/R73G/czQMAAAAAAAAAAIwjogYAYEhn91J7Pe/I/rue95/9Ifv1d2Z//VlPXvK7/e5lFX+vDrzrn3V9L9O+rUfv33Lo9qP7tJ4+Z2ZvXPG9sm5D3sZGAAAAAAAAAABgGEQNAACjIDOjrB733d89tv3tuf/bvGyeI+u1Tnsc6/akr9ndp7x7Ob39b6ru+Z/ke7b7qtd78ak+oPd19drN5JwAAAAAAAAAAMEwmagIAOJis6Zv9W0973K/fs8v873dfPjP7jSnLNa+XZz7Va/fxjTcf1Zcrvd9XX557Ps2xZAAAAAAAAAAAwVCRqAgA4k93dXfe1/17qvfTb7j855rnPX7/SXl59R5/UuWvr9bzd5S6/zbw9ub3Ob+r2/dc3zT9en6fuo+3X1+WAAAAAAAAAAAwdCRqAgA4mtzoM7tO+2vfX7/K/gn7LavnXTnZK+fdttJ+1nn5bT2n9sfVuwIAAAAAAAAAAGCYSDUAANwll78euudvuf//Lf1Y3L7PX/ctc9f/L/ez3ja3TwAAAAAAAAAAgHFENQAAnCOzt3v3Z89v/z3ZO89997rnvY/57nbfLPufaT3nF4NAAAAAAAAAACMODYqAQAAAAAAAMAwICoBAAAAAAAAwDAgKgEAAAAAAAAwDLAJtQXgXDpdwAAAABJRU5ErkJggg==">
  <meta name="theme-color" content="#0f172a">
  <link rel="preconnect" href="https://ipapi.co" crossorigin>
  <link rel="preconnect" href="https://www.cloudflare.com" crossorigin>
  <link rel="preconnect" href="https://speed.cloudflare.com" crossorigin>
  <link rel="preconnect" href="https://httpbin.org" crossorigin>
  <title>TestDebit | Ultra-Precise Internet Speed Test</title>
  <style>
    :root {
      color-scheme: dark light;
      --bg-gradient: radial-gradient(circle at 20% 20%, rgba(81,94,181,0.6), transparent 55%), radial-gradient(circle at 80% 10%, rgba(65,153,214,0.6), transparent 60%), linear-gradient(135deg, #060912 0%, #0b1529 45%, #101b35 100%);
      --panel-bg: rgba(15, 23, 42, 0.8);
      --panel-border: rgba(148, 163, 184, 0.15);
      --accent: #5e8bff;
      --accent-strong: #6a5eff;
      --accent-gradient: linear-gradient(135deg, #5e8bff 0%, #7f5bff 50%, #4cd4ff 100%);
      --text-primary: #f8fafc;
      --text-secondary: #cbd5f5;
      --success: #22c55e;
      --warning: #facc15;
      --danger: #f87171;
      --neutral: rgba(148, 163, 184, 0.25);
      --shadow-strong: 0 25px 60px rgba(15, 23, 42, 0.6);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #05070f;
    }

    [data-theme="light"] {
      --bg-gradient: radial-gradient(circle at 20% 20%, rgba(94, 139, 255, 0.2), transparent 55%), radial-gradient(circle at 80% 10%, rgba(76, 212, 255, 0.2), transparent 60%), linear-gradient(135deg, #f8fafc 0%, #eef2ff 100%);
      --panel-bg: rgba(248, 250, 252, 0.75);
      --panel-border: rgba(100, 116, 139, 0.15);
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --shadow-strong: 0 25px 45px rgba(15, 23, 42, 0.2);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg-gradient);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2.5rem clamp(1rem, 4vw, 3rem);
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: linear-gradient(120deg, rgba(94, 139, 255, 0.25), rgba(76, 212, 255, 0.08));
      opacity: 0.35;
      pointer-events: none;
      animation: bgPulse 18s infinite alternate;
    }

    @keyframes bgPulse {
      0% { opacity: 0.25; }
      50% { opacity: 0.45; }
      100% { opacity: 0.3; }
    }

    .app {
      width: min(1200px, 100%);
      backdrop-filter: blur(24px) saturate(140%);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 32px;
      box-shadow: var(--shadow-strong);
      position: relative;
      overflow: hidden;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: clamp(1.25rem, 2.5vw, 2rem) clamp(1.5rem, 3vw, 3rem) 1rem;
      gap: 1rem;
    }

    .branding {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .branding h1 {
      margin: 0;
      font-size: clamp(1.35rem, 2.5vw, 1.8rem);
      letter-spacing: 0.04em;
    }

    .branding span {
      font-size: clamp(0.85rem, 2vw, 0.95rem);
      color: var(--text-secondary);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    button, .pill {
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.1rem;
      background: rgba(94, 139, 255, 0.09);
      color: var(--text-primary);
      font-weight: 600;
      letter-spacing: 0.02em;
      transition: transform 0.25s ease, box-shadow 0.25s ease, background 0.3s ease;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }

    button:hover:not(:disabled), .pill:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(94, 139, 255, 0.25);
      background: rgba(94, 139, 255, 0.18);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    .theme-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      background: rgba(148, 163, 184, 0.12);
    }

    .theme-toggle svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    main {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: clamp(1.25rem, 3vw, 2rem);
      padding: 0 clamp(1.75rem, 3vw, 3rem) clamp(1.75rem, 3vw, 3rem);
    }

    .gauge-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, rgba(94, 139, 255, 0.12), rgba(124, 58, 237, 0.1));
      border-radius: 28px;
      border: 1px solid rgba(94, 139, 255, 0.14);
      position: relative;
      padding: clamp(1.75rem, 4vw, 3rem);
      overflow: hidden;
    }

    .gauge-panel::before {
      content: "";
      position: absolute;
      inset: 18px;
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      pointer-events: none;
    }

    .gauge-container {
      position: relative;
      width: min(360px, 70vw);
      aspect-ratio: 1 / 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .gauge-svg {
      width: 100%;
      height: auto;
    }

    .gauge-center {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.45rem;
      text-align: center;
    }

    .gauge-value {
      display: flex;
      align-items: baseline;
      gap: 0.35rem;
      font-size: clamp(2.8rem, 6vw, 3.8rem);
      font-weight: 700;
    }

    .gauge-value span {
      font-size: clamp(1rem, 2vw, 1.35rem);
      color: var(--text-secondary);
    }

    .gauge-phase {
      font-size: clamp(0.9rem, 2.2vw, 1.1rem);
      color: var(--text-secondary);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .start-button {
      position: relative;
      width: clamp(140px, 25vw, 170px);
      height: clamp(140px, 25vw, 170px);
      border-radius: 50%;
      background: var(--accent-gradient);
      color: #fff;
      font-size: clamp(1.1rem, 3vw, 1.4rem);
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      border: none;
      cursor: pointer;
      box-shadow: 0 18px 40px rgba(94, 139, 255, 0.4);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .start-button:hover:not(:disabled) {
      transform: scale(1.03);
      box-shadow: 0 20px 45px rgba(94, 139, 255, 0.5);
    }

    .start-button:disabled {
      background: linear-gradient(135deg, rgba(94, 139, 255, 0.7), rgba(124, 58, 237, 0.65));
      box-shadow: none;
    }

    .status-badges {
      margin-top: 1.5rem;
      display: flex;
      gap: 0.7rem;
      flex-wrap: wrap;
      justify-content: center;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .status-badge {
      padding: 0.45rem 0.85rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.12);
      display: flex;
      align-items: center;
      gap: 0.45rem;
    }

    .status-badge .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--neutral);
      transition: background 0.3s ease;
    }

    .status-badge.active .dot {
      background: var(--accent);
    }

    .status-badge.success .dot {
      background: var(--success);
    }

    .status-badge.error .dot {
      background: var(--danger);
    }

    .metrics-panel {
      display: flex;
      flex-direction: column;
      gap: clamp(1.25rem, 3vw, 1.75rem);
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
    }

    .metric-card {
      background: rgba(15, 23, 42, 0.6);
      border-radius: 18px;
      border: 1px solid rgba(94, 139, 255, 0.12);
      padding: 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      transition: transform 0.3s ease;
    }

    [data-theme="light"] .metric-card {
      background: rgba(255, 255, 255, 0.7);
    }

    .metric-card:hover {
      transform: translateY(-4px);
    }

    .metric-label {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-secondary);
    }

    .metric-value {
      font-size: clamp(1.8rem, 3.5vw, 2.35rem);
      font-weight: 700;
    }

    .metric-unit {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-left: 0.35rem;
    }

    .quality-indicator {
      background: rgba(34, 197, 94, 0.15);
      border: 1px solid rgba(34, 197, 94, 0.3);
      color: var(--text-primary);
      border-radius: 16px;
      padding: 1rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .quality-label {
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .quality-description {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .connection-panel {
      background: rgba(15, 23, 42, 0.55);
      border-radius: 20px;
      padding: 1.25rem;
      border: 1px solid rgba(94, 139, 255, 0.12);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1.1rem;
    }

    .connection-panel h3 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .connection-detail {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      font-size: 0.95rem;
    }

    .connection-detail strong {
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .phases {
      display: grid;
      gap: 0.75rem;
      background: rgba(148, 163, 184, 0.08);
      border-radius: 18px;
      padding: 1rem 1.1rem;
      border: 1px solid rgba(148, 163, 184, 0.12);
    }

    .phase-item {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 0.8rem;
      font-size: 0.95rem;
    }

    .phase-item .label {
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-secondary);
      font-size: 0.8rem;
    }

    .phase-status {
      font-weight: 600;
    }

    .phase-progress {
      height: 6px;
      background: rgba(94, 139, 255, 0.12);
      border-radius: 999px;
      overflow: hidden;
    }

    .phase-progress span {
      display: block;
      height: 100%;
      width: 0%;
      background: var(--accent-gradient);
      transition: width 0.3s ease;
    }

    .history-panel {
      background: rgba(15, 23, 42, 0.55);
      border-radius: 20px;
      border: 1px solid rgba(94, 139, 255, 0.12);
      padding: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .history-panel header {
      padding: 0;
    }

    .history-panel h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .history-empty {
      font-size: 0.95rem;
      color: var(--text-secondary);
    }

    canvas {
      width: 100%;
      max-height: 160px;
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      margin-top: 0.5rem;
    }

    .actions button {
      flex: 1;
      min-width: 140px;
      background: rgba(94, 139, 255, 0.2);
    }

    .actions button.secondary {
      background: rgba(148, 163, 184, 0.15);
    }

    .toast {
      position: fixed;
      bottom: clamp(1rem, 3vw, 2rem);
      right: clamp(1rem, 3vw, 2.25rem);
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(94, 139, 255, 0.25);
      border-radius: 16px;
      padding: 0.9rem 1.1rem;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.7rem;
      box-shadow: 0 20px 48px rgba(15, 23, 42, 0.45);
      transform: translateY(150%);
      opacity: 0;
      transition: transform 0.4s ease, opacity 0.4s ease;
      max-width: min(320px, calc(100vw - 2rem));
      z-index: 20;
    }

    .toast.show {
      transform: translateY(0%);
      opacity: 1;
    }

    .toast strong {
      font-size: 0.95rem;
    }

    .toast span {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    footer {
      padding: 0  clamp(1.75rem, 3vw, 3rem) clamp(1.75rem, 3vw, 3rem);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.8rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .loading-spinner {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 3px solid rgba(94, 139, 255, 0.25);
      border-top-color: #7c5bff;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 1024px) {
      main {
        grid-template-columns: 1fr;
      }

      .gauge-panel {
        order: -1;
      }

      footer {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    @media (max-width: 720px) {
      body {
        padding: 1.5rem 1rem;
      }

      .app {
        border-radius: 24px;
      }

      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .header-actions {
        width: 100%;
        justify-content: flex-start;
      }

      .start-button {
        width: clamp(130px, 40vw, 160px);
        height: clamp(130px, 40vw, 160px);
      }

      .status-badges {
        justify-content: flex-start;
      }

      .actions button {
        flex: initial;
        width: 100%;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="TestDebit internet speed test">
    <header>
      <div class="branding">
        <h1>TestDebit</h1>
        <span>Ultra-precise internet speed diagnostics</span>
      </div>
      <div class="header-actions">
        <div class="pill" id="connection-status" aria-live="polite">Initializing...</div>
        <button class="theme-toggle" id="theme-toggle" type="button" aria-label="Toggle theme">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3a1 1 0 0 1 1 1v1.06A7.002 7.002 0 0 1 18.94 11H20a1 1 0 1 1 0 2h-1.06A7.002 7.002 0 0 1 13 18.94V20a1 1 0 1 1-2 0v-1.06A7.002 7.002 0 0 1 5.06 13H4a1 1 0 1 1 0-2h1.06A7.002 7.002 0 0 1 11 5.06V4a1 1 0 0 1 1-1Zm0 4a5 5 0 1 0 0 10 5 5 0 0 0 0-10Z"/></svg>
          Theme
        </button>
      </div>
    </header>
    <main>
      <section class="gauge-panel" aria-labelledby="speedometer-heading">
        <h2 id="speedometer-heading" class="visually-hidden">Speedometer</h2>
        <div class="gauge-container">
          <svg class="gauge-svg" viewBox="0 0 200 200" role="img" aria-label="Speedometer gauge">
            <defs>
              <linearGradient id="gaugeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#5e8bff"/>
                <stop offset="50%" stop-color="#7f5bff"/>
                <stop offset="100%" stop-color="#4cd4ff"/>
              </linearGradient>
            </defs>
            <circle cx="100" cy="100" r="86" stroke="rgba(148, 163, 184, 0.15)" stroke-width="14" fill="none" stroke-linecap="round"/>
            <path id="gauge-arc" d="M36.6 133.4 A86 86 0 0 1 163.4 133.4" stroke="url(#gaugeGradient)" stroke-width="14" fill="none" stroke-linecap="round" stroke-dasharray="270" stroke-dashoffset="270"/>
            <circle cx="100" cy="100" r="6" fill="#fff" opacity="0.7"/>
            <line id="gauge-needle" x1="100" y1="100" x2="100" y2="26" stroke="#fff" stroke-width="4" stroke-linecap="round" transform="rotate(-135 100 100)"/>
          </svg>
          <div class="gauge-center">
            <div class="gauge-phase" id="gauge-phase-label">Idle</div>
            <div class="gauge-value" aria-live="polite"><span id="gauge-value">0.00</span><span id="gauge-unit">Mbps</span></div>
            <button class="start-button" id="start-button" type="button">Go</button>
          </div>
        </div>
        <div class="status-badges" role="status" aria-live="polite">
          <div class="status-badge" data-phase="ping"><span class="dot"></span>Ping</div>
          <div class="status-badge" data-phase="download"><span class="dot"></span>Download</div>
          <div class="status-badge" data-phase="upload"><span class="dot"></span>Upload</div>
        </div>
      </section>
      <aside class="metrics-panel">
        <section class="metrics-grid" aria-label="Live metrics">
          <article class="metric-card" id="metric-ping" role="group" aria-labelledby="metric-ping-label">
            <div class="metric-label" id="metric-ping-label">Ping</div>
            <div><span class="metric-value" data-field="ping">--</span><span class="metric-unit">ms</span></div>
            <small class="metric-sub" data-field="ping-meta">Awaiting test...</small>
          </article>
          <article class="metric-card" id="metric-jitter" role="group" aria-labelledby="metric-jitter-label">
            <div class="metric-label" id="metric-jitter-label">Jitter</div>
            <div><span class="metric-value" data-field="jitter">--</span><span class="metric-unit">ms</span></div>
            <small class="metric-sub" data-field="jitter-meta">Awaiting test...</small>
          </article>
          <article class="metric-card" id="metric-download" role="group" aria-labelledby="metric-download-label">
            <div class="metric-label" id="metric-download-label">Download</div>
            <div><span class="metric-value" data-field="download">--</span><span class="metric-unit">Mbps</span></div>
            <small class="metric-sub" data-field="download-meta">Awaiting test...</small>
          </article>
          <article class="metric-card" id="metric-upload" role="group" aria-labelledby="metric-upload-label">
            <div class="metric-label" id="metric-upload-label">Upload</div>
            <div><span class="metric-value" data-field="upload">--</span><span class="metric-unit">Mbps</span></div>
            <small class="metric-sub" data-field="upload-meta">Awaiting test...</small>
          </article>
        </section>
        <section class="quality-indicator" aria-live="polite">
          <div class="quality-label">Network Quality</div>
          <div class="quality-score" id="quality-score">Unknown</div>
          <div class="quality-description" id="quality-description">Run a test to evaluate your connection.</div>
        </section>
        <section class="connection-panel" aria-label="Connection details">
          <div class="connection-detail">
            <strong>IPAddress</strong>
            <span id="ip-address">Fetching...</span>
          </div>
          <div class="connection-detail">
            <strong>ISP</strong>
            <span id="isp">Fetching...</span>
          </div>
          <div class="connection-detail">
            <strong>LOCATION</strong>
            <span id="location">Fetching...</span>
          </div>
        </section>
        <section class="phases" aria-live="polite">
          <div class="phase-item" data-phase="ping">
            <span class="label">Ping</span>
            <div class="phase-progress"><span></span></div>
            <span class="phase-status" data-phase-status="ping">Idle</span>
          </div>
          <div class="phase-item" data-phase="download">
            <span class="label">Download</span>
            <div class="phase-progress"><span></span></div>
            <span class="phase-status" data-phase-status="download">Idle</span>
          </div>
          <div class="phase-item" data-phase="upload">
            <span class="label">Upload</span>
            <div class="phase-progress"><span></span></div>
            <span class="phase-status" data-phase-status="upload">Idle</span>
          </div>
        </section>
        <section class="history-panel" aria-label="Speed history">
          <header>
            <h2>Recent Results</h2>
          </header>
          <canvas id="history-chart" width="480" height="160" role="img" aria-label="Download and upload history trend"></canvas>
          <div class="history-empty" id="history-empty">No tests yet. Results will appear here.</div>
        </section>
        <div class="actions">
          <button type="button" id="test-again" class="secondary" disabled>Test Again</button>
          <button type="button" id="copy-results" class="secondary" disabled>Copy Results</button>
        </div>
      </aside>
    </main>
    <footer>
      <div>All tests run directly from your browser. No data stored server-side.</div>
      <div>&copy; <span id="year"></span> TestDebit. Built for accuracy and privacy.</div>
    </footer>
  </div>
  <div class="toast" role="alert" aria-live="assertive" id="toast">
    <div class="loading-spinner" aria-hidden="true"></div>
    <div>
      <strong id="toast-title">Status</strong>
      <span id="toast-message">...</span>
    </div>
  </div>
  <style>
    .visually-hidden {
      border: 0 !important;
      clip: rect(1px, 1px, 1px, 1px);
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute !important;
      width: 1px;
      white-space: nowrap;
    }
  </style>
  <script>
    (function() {
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const storedTheme = localStorage.getItem('testdebit-theme');
      const initialTheme = storedTheme || (prefersDark ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', initialTheme);
    })();
  </script>
  <script>
    (() => {
      'use strict';

      const MAX_DOWNLOAD_SPEED = 1000; // Mbps gauge cap for download
      const MAX_UPLOAD_SPEED = 500; // Mbps gauge cap for upload
      const MAX_PING = 200; // ms gauge cap for latency visuals
      const HISTORY_KEY = 'testdebit-history-v1';
      const THEME_KEY = 'testdebit-theme';
      const MAX_HISTORY_ITEMS = 5;
      const TEST_TIMEOUT_MS = 30000;
      const DOWNLOAD_TARGET_DURATION = 12000; // 12 seconds target window
      const UPLOAD_TARGET_DURATION = 12000;
      const PING_REQUESTS = 8;

      const ui = {
        startButton: document.getElementById('start-button'),
        gaugeValue: document.getElementById('gauge-value'),
        gaugeUnit: document.getElementById('gauge-unit'),
        gaugePhase: document.getElementById('gauge-phase-label'),
        gaugeNeedle: document.getElementById('gauge-needle'),
        gaugeArc: document.getElementById('gauge-arc'),
        statusBadges: document.querySelectorAll('.status-badge'),
        metricValues: {
          ping: document.querySelector('[data-field="ping"]'),
          jitter: document.querySelector('[data-field="jitter"]'),
          download: document.querySelector('[data-field="download"]'),
          upload: document.querySelector('[data-field="upload"]'),
        },
        metricMeta: {
          ping: document.querySelector('[data-field="ping-meta"]'),
          jitter: document.querySelector('[data-field="jitter-meta"]'),
          download: document.querySelector('[data-field="download-meta"]'),
          upload: document.querySelector('[data-field="upload-meta"]'),
        },
        phaseStatuses: {
          ping: document.querySelector('[data-phase-status="ping"]'),
          download: document.querySelector('[data-phase-status="download"]'),
          upload: document.querySelector('[data-phase-status="upload"]'),
        },
        phaseProgress: {
          ping: document.querySelector('.phase-item[data-phase="ping"] .phase-progress span'),
          download: document.querySelector('.phase-item[data-phase="download"] .phase-progress span'),
          upload: document.querySelector('.phase-item[data-phase="upload"] .phase-progress span'),
        },
        historyCanvas: document.getElementById('history-chart'),
        historyEmpty: document.getElementById('history-empty'),
        testAgain: document.getElementById('test-again'),
        copyResults: document.getElementById('copy-results'),
        toast: document.getElementById('toast'),
        toastTitle: document.getElementById('toast-title'),
        toastMessage: document.getElementById('toast-message'),
        connectionStatus: document.getElementById('connection-status'),
        ipAddress: document.getElementById('ip-address'),
        isp: document.getElementById('isp'),
        location: document.getElementById('location'),
        qualityScore: document.getElementById('quality-score'),
        qualityDescription: document.getElementById('quality-description'),
        themeToggle: document.getElementById('theme-toggle'),
      };

      const gaugeState = {
        targetValue: 0,
        displayedValue: 0,
        phase: 'download',
        unit: 'Mbps',
        animationFrame: null,
      };

      let worker = null;
      let latestResults = null;
      let history = loadHistory();
      const gaugeOffsetBase = 270;
      const gaugeMinAngle = -135;
      const gaugeMaxAngle = 135;

      function formatNumber(value, fractionDigits = 2) {
        if (!Number.isFinite(value)) {
          return '--';
        }
        if (value >= 100) {
          return value.toFixed(1);
        }
        return value.toFixed(fractionDigits);
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function setGaugePhase(phase, unit, maxValue) {
        gaugeState.phase = phase;
        gaugeState.unit = unit;
        gaugeState.maxValue = maxValue;
        ui.gaugePhase.textContent = phase;
        ui.gaugeUnit.textContent = unit;
      }

      function updateGaugeTarget(value) {
        const maxValue = gaugeState.maxValue || MAX_DOWNLOAD_SPEED;
        const normalized = clamp(value / maxValue, 0, 1);
        const targetAngle = gaugeMinAngle + (gaugeMaxAngle - gaugeMinAngle) * normalized;
        gaugeState.targetAngle = targetAngle;
        gaugeState.targetValue = value;
        if (!gaugeState.animationFrame) {
          gaugeState.animationFrame = requestAnimationFrame(animateGauge);
        }
      }

      function animateGauge() {
        const angleDiff = gaugeState.targetAngle - (gaugeState.currentAngle || gaugeMinAngle);
        const valueDiff = gaugeState.targetValue - gaugeState.displayedValue;

        const angleStep = angleDiff * 0.12;
        const valueStep = valueDiff * 0.18;

        const newAngle = (gaugeState.currentAngle || gaugeMinAngle) + angleStep;
        const newValue = gaugeState.displayedValue + valueStep;

        gaugeState.currentAngle = Math.abs(angleDiff) < 0.2 ? gaugeState.targetAngle : newAngle;
        gaugeState.displayedValue = Math.abs(valueDiff) < 0.02 ? gaugeState.targetValue : newValue;

        const offset = gaugeOffsetBase - (gaugeOffsetBase * ((gaugeState.currentAngle - gaugeMinAngle) / (gaugeMaxAngle - gaugeMinAngle)));
        ui.gaugeArc.style.strokeDashoffset = offset.toString();
        ui.gaugeNeedle.setAttribute('transform', `rotate(${gaugeState.currentAngle} 100 100)`);
        ui.gaugeValue.textContent = formatNumber(Math.abs(gaugeState.displayedValue), gaugeState.unit === 'Mbps' ? 2 : 1);

        if (Math.abs(angleDiff) > 0.2 || Math.abs(valueDiff) > 0.02) {
          gaugeState.animationFrame = requestAnimationFrame(animateGauge);
        } else {
          gaugeState.animationFrame = null;
        }
      }

      function resetGauge() {
        if (gaugeState.animationFrame) {
          cancelAnimationFrame(gaugeState.animationFrame);
          gaugeState.animationFrame = null;
        }
        setGaugePhase('Idle', 'Mbps', MAX_DOWNLOAD_SPEED);
        gaugeState.targetValue = 0;
        gaugeState.displayedValue = 0;
        gaugeState.currentAngle = gaugeMinAngle;
        gaugeState.targetAngle = gaugeMinAngle;
        ui.gaugeArc.style.strokeDashoffset = gaugeOffsetBase;
        ui.gaugeNeedle.setAttribute('transform', `rotate(${gaugeMinAngle} 100 100)`);
        ui.gaugeValue.textContent = '0.00';
      }

      function setStatusBadge(phase, status) {
        ui.statusBadges.forEach(badge => {
          if (badge.dataset.phase === phase) {
            badge.classList.remove('active', 'success', 'error');
            if (status === 'active') badge.classList.add('active');
            if (status === 'success') badge.classList.add('success');
            if (status === 'error') badge.classList.add('error');
          }
        });
      }

      function showToast(title, message, duration = 4000) {
        ui.toastTitle.textContent = title;
        ui.toastMessage.textContent = message;
        ui.toast.classList.add('show');
        clearTimeout(showToast.timeoutId);
        showToast.timeoutId = setTimeout(() => {
          ui.toast.classList.remove('show');
        }, duration);
      }

      async function fetchConnectionInfo() {
        try {
          ui.connectionStatus.textContent = 'Fetching IP info…';
          const response = await fetch('https://ipapi.co/json/', { cache: 'no-cache' });
          if (!response.ok) throw new Error('ipapi request failed');
          const data = await response.json();
          renderConnectionInfo(data);
        } catch (error) {
          console.warn('ipapi failed, attempting fallback', error);
          await fetchConnectionInfoFallback();
        }
      }

      async function fetchConnectionInfoFallback() {
        try {
          const ipRes = await fetch('https://api.ipify.org?format=json');
          if (!ipRes.ok) throw new Error('ipify failed');
          const { ip } = await ipRes.json();
          const geoRes = await fetch(`https://ipapi.co/${ip}/json/`);
          if (!geoRes.ok) throw new Error('ipapi fallback failed');
          const data = await geoRes.json();
          renderConnectionInfo({ ...data, ip });
        } catch (fallbackError) {
          console.error('Failed to fetch IP details', fallbackError);
          ui.connectionStatus.textContent = 'IP lookup unavailable';
          ui.ipAddress.textContent = 'Unavailable';
          ui.isp.textContent = 'Unavailable';
          ui.location.textContent = 'Unavailable';
        }
      }

      function renderConnectionInfo(data) {
        const { ip, org, city, region, country_name: countryName, isp } = data;
        ui.ipAddress.textContent = ip || 'Unknown';
        ui.isp.textContent = isp || org || 'Unknown';
        const locationParts = [city, region, countryName || data.country];
        ui.location.textContent = locationParts.filter(Boolean).join(', ') || 'Unknown location';
        ui.connectionStatus.textContent = 'Ready';
      }

      function loadHistory() {
        try {
          const data = localStorage.getItem(HISTORY_KEY);
          if (!data) return [];
          const parsed = JSON.parse(data);
          if (Array.isArray(parsed)) {
            return parsed.slice(-MAX_HISTORY_ITEMS);
          }
        } catch (error) {
          console.warn('Failed to parse history', error);
        }
        return [];
      }

      function saveHistory() {
        try {
          localStorage.setItem(HISTORY_KEY, JSON.stringify(history.slice(-MAX_HISTORY_ITEMS)));
        } catch (error) {
          console.warn('Failed to save history', error);
        }
      }

      function renderHistory() {
        const ctx = ui.historyCanvas.getContext('2d');
        if (!ctx) {
          console.warn('History canvas context unavailable.');
          return;
        }
        ctx.clearRect(0, 0, ui.historyCanvas.width, ui.historyCanvas.height);
        if (history.length === 0) {
          ui.historyEmpty.style.display = 'block';
          return;
        }
        ui.historyEmpty.style.display = 'none';
        const padding = 24;
        const width = ui.historyCanvas.width - padding * 2;
        const height = ui.historyCanvas.height - padding * 2;
        const maxDownload = Math.max(...history.map(entry => entry.downloadMbps));
        const maxUpload = Math.max(...history.map(entry => entry.uploadMbps));
        const maxValue = Math.max(maxDownload, maxUpload, 10);

        const gradientDownload = ctx.createLinearGradient(padding, padding, padding, padding + height);
        gradientDownload.addColorStop(0, 'rgba(94, 139, 255, 0.6)');
        gradientDownload.addColorStop(1, 'rgba(76, 212, 255, 0.2)');

        const gradientUpload = ctx.createLinearGradient(padding, padding, padding, padding + height);
        gradientUpload.addColorStop(0, 'rgba(124, 58, 237, 0.6)');
        gradientUpload.addColorStop(1, 'rgba(94, 139, 255, 0.2)');

        drawLine(ctx, history, entry => entry.downloadMbps, padding, width, height, maxValue, gradientDownload);
        drawLine(ctx, history, entry => entry.uploadMbps, padding, width, height, maxValue, gradientUpload);

        ctx.save();
        ctx.fillStyle = 'rgba(148, 163, 184, 0.45)';
        ctx.font = '12px Inter, sans-serif';
        ctx.textBaseline = 'top';
        history.forEach((entry, index) => {
          const x = padding + (width / Math.max(history.length - 1, 1)) * index;
          ctx.fillText(entry.label, x - 20, padding + height + 6);
        });
        ctx.restore();
      }

      function drawLine(ctx, list, accessor, padding, width, height, maxValue, strokeStyle) {
        if (list.length === 0) return;
        ctx.save();
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 3;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        list.forEach((entry, index) => {
          const x = padding + (width / Math.max(list.length - 1, 1)) * index;
          const percentage = accessor(entry) / maxValue;
          const y = padding + height - percentage * height;
          if (index === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.restore();
      }

      function resetMetrics() {
        Object.values(ui.metricValues).forEach(el => { el.textContent = '--'; });
        ui.metricMeta.ping.textContent = 'Awaiting test...';
        ui.metricMeta.jitter.textContent = 'Awaiting test...';
        ui.metricMeta.download.textContent = 'Awaiting test...';
        ui.metricMeta.upload.textContent = 'Awaiting test...';
        Object.values(ui.phaseStatuses).forEach(el => { el.textContent = 'Idle'; });
        Object.values(ui.phaseProgress).forEach(el => { el.style.width = '0%'; });
        ui.testAgain.disabled = true;
        ui.copyResults.disabled = true;
        setStatusBadge('ping', '');
        setStatusBadge('download', '');
        setStatusBadge('upload', '');
        latestResults = null;
        ui.qualityScore.textContent = 'Unknown';
        ui.qualityDescription.textContent = 'Run a test to evaluate your connection.';
      }

      function computeNetworkQuality(results) {
        if (!results) return { label: 'Unknown', description: 'Run a test to evaluate your connection.' };
        const { downloadMbps, uploadMbps, pingMs, jitterMs } = results;
        const score = (downloadMbps / 500) * 40 + (uploadMbps / 250) * 35 + Math.max(0, (150 - pingMs)) / 150 * 15 + Math.max(0, (80 - jitterMs)) / 80 * 10;
        if (score >= 80) {
          return { label: 'Excellent', description: 'Ready for UHD streaming, cloud gaming, and large uploads.' };
        }
        if (score >= 60) {
          return { label: 'Good', description: 'Great for HD streaming, work calls, and quick downloads.' };
        }
        if (score >= 40) {
          return { label: 'Fair', description: 'Suitable for browsing and HD streaming. Expect occasional hiccups.' };
        }
        return { label: 'Poor', description: 'Latency-sensitive activities may suffer. Consider troubleshooting.' };
      }

      function handleWorkerMessage(event) {
        const { type, payload } = event.data;
        switch (type) {
          case 'phase':
            handlePhaseUpdate(payload);
            break;
          case 'progress':
            handleProgressUpdate(payload);
            break;
          case 'metrics':
            handleMetrics(payload);
            break;
          case 'error':
            handleError(payload);
            break;
          default:
            break;
        }
      }

      function handlePhaseUpdate(payload) {
        const { phase, status } = payload;
        if (ui.phaseStatuses[phase]) {
          ui.phaseStatuses[phase].textContent = status;
        }
        if (status === 'Testing…') {
          setStatusBadge(phase, 'active');
        } else if (status === 'Complete') {
          setStatusBadge(phase, 'success');
        }

        if (phase === 'ping') {
          setGaugePhase('Ping', 'ms', MAX_PING);
        } else if (phase === 'download') {
          setGaugePhase('Download', 'Mbps', MAX_DOWNLOAD_SPEED);
        } else if (phase === 'upload') {
          setGaugePhase('Upload', 'Mbps', MAX_UPLOAD_SPEED);
        }

        if (payload.progress !== undefined && ui.phaseProgress[phase]) {
          ui.phaseProgress[phase].style.width = `${payload.progress}%`;
        }
      }

      function handleProgressUpdate(payload) {
        const { phase, instantValue, averageValue, progress } = payload;
        if (phase === 'download' || phase === 'upload') {
          const value = instantValue ?? averageValue;
          updateGaugeTarget(value || 0);
          if (ui.metricValues[phase]) {
            ui.metricValues[phase].textContent = formatNumber(averageValue || value || 0, 2);
          }
          if (ui.metricMeta[phase]) {
            const info = phase === 'download' ? 'Measuring throughput…' : 'Measuring upstream…';
            ui.metricMeta[phase].textContent = `${info} ${formatNumber(value || 0, 2)} ${phase === 'download' ? 'Mbps' : 'Mbps'}`;
          }
        }
        if (phase === 'ping') {
          updateGaugeTarget(instantValue || 0);
          ui.metricValues.ping.textContent = formatNumber(averageValue || instantValue || 0, 2);
          ui.metricMeta.ping.textContent = `Latency samples: ${payload.samples || 0}`;
        }
        if (ui.phaseProgress[phase]) {
          ui.phaseProgress[phase].style.width = `${progress}%`;
        }
      }

      function handleMetrics(results) {
        latestResults = results;
        const { downloadMbps, uploadMbps, pingMs, jitterMs, pingDetails } = results;

        ui.metricValues.download.textContent = formatNumber(downloadMbps, 2);
        ui.metricValues.upload.textContent = formatNumber(uploadMbps, 2);
        ui.metricValues.ping.textContent = formatNumber(pingMs, 2);
        ui.metricValues.jitter.textContent = formatNumber(jitterMs, 2);

        ui.metricMeta.download.textContent = `Average across ${results.downloadSamples} samples`;
        ui.metricMeta.upload.textContent = `Average across ${results.uploadSamples} samples`;
        ui.metricMeta.ping.textContent = `min ${formatNumber(pingDetails.min, 2)} ms / max ${formatNumber(pingDetails.max, 2)} ms`;
        ui.metricMeta.jitter.textContent = `Based on ${pingDetails.count} latency samples`;

        setGaugePhase('Complete', 'Mbps', MAX_DOWNLOAD_SPEED);
        updateGaugeTarget(downloadMbps);

        setStatusBadge('ping', 'success');
        setStatusBadge('download', 'success');
        setStatusBadge('upload', 'success');
        Object.keys(ui.phaseProgress).forEach(phase => {
          ui.phaseProgress[phase].style.width = '100%';
          ui.phaseStatuses[phase].textContent = 'Complete';
        });

        ui.startButton.disabled = false;
        ui.startButton.textContent = 'Go';
        ui.testAgain.disabled = false;
        ui.copyResults.disabled = false;

        const quality = computeNetworkQuality(results);
        ui.qualityScore.textContent = quality.label;
        ui.qualityDescription.textContent = quality.description;

        appendToHistory(results);
        showToast('Test complete', 'Results saved locally.');
        terminateWorker();
      }

      function handleError(payload) {
        console.error('Worker error', payload);
        ui.startButton.disabled = false;
        ui.startButton.textContent = 'Go';
        ui.testAgain.disabled = false;
        ui.copyResults.disabled = latestResults === null;
        const phaseText = payload.phase ? `${payload.phase.charAt(0).toUpperCase()}${payload.phase.slice(1)} phase` : 'Speed test';
        const message = payload.message || 'Speed test failed.';
        showToast('Error', `${phaseText}: ${message}`);
        if (payload.phase) {
          setStatusBadge(payload.phase, 'error');
          if (ui.phaseStatuses[payload.phase]) {
            ui.phaseStatuses[payload.phase].textContent = 'Error';
          }
        } else {
          ['ping', 'download', 'upload'].forEach(phase => {
            setStatusBadge(phase, 'error');
            if (ui.phaseStatuses[phase]) {
              ui.phaseStatuses[phase].textContent = 'Error';
            }
          });
        }
        terminateWorker();
      }

      function terminateWorker() {
        if (worker) {
          worker.terminate();
          worker = null;
        }
      }

      function appendToHistory(entry) {
        const timestamp = new Date(entry.timestamp);
        const label = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        history.push({
          downloadMbps: entry.downloadMbps,
          uploadMbps: entry.uploadMbps,
          pingMs: entry.pingMs,
          jitterMs: entry.jitterMs,
          label,
        });
        history = history.slice(-MAX_HISTORY_ITEMS);
        saveHistory();
        renderHistory();
      }

      function createWorker() {
        const workerScript = `(() => {
          const TEST_TIMEOUT_MS = ${TEST_TIMEOUT_MS};
          const DOWNLOAD_TARGET_DURATION = ${DOWNLOAD_TARGET_DURATION};
          const UPLOAD_TARGET_DURATION = ${UPLOAD_TARGET_DURATION};
          const PING_REQUESTS = ${PING_REQUESTS};
          const DOWNLOAD_SIZES = [1048576, 5242880, 10485760];
          const UPLOAD_SIZES = [524288, 2097152, 5242880];
          const DOWNLOAD_CONCURRENCY = 3;
          const UPLOAD_CONCURRENCY = 2;
          const MAX_ATTEMPTS = 3;
          const BACKOFF_MS = 250;
          const PING_ENDPOINT = 'https://www.cloudflare.com/cdn-cgi/trace';

          self.onmessage = async (event) => {
            const { type } = event.data;
            if (type === 'start') {
              try {
                const timestamp = Date.now();
                const pingMetrics = await runPingTest();
                const downloadMetrics = await runDownloadTest();
                const uploadMetrics = await runUploadTest();

                const results = {
                  timestamp,
                  pingMs: pingMetrics.average,
                  jitterMs: pingMetrics.jitter,
                  pingDetails: pingMetrics,
                  downloadMbps: downloadMetrics.averageMbps,
                  uploadMbps: uploadMetrics.averageMbps,
                  downloadSamples: downloadMetrics.samples,
                  uploadSamples: uploadMetrics.samples,
                };
                postMessage({ type: 'metrics', payload: results });
              } catch (error) {
                const err = error instanceof Error ? error : new Error(String(error));
                postMessage({ type: 'error', payload: { message: err.message || 'Speed test failed', phase: err.phase } });
              }
            }
          };

          async function runPingTest() {
            const samples = [];
            postMessage({ type: 'phase', payload: { phase: 'ping', status: 'Testing…', progress: 0 } });
            for (let i = 0; i < PING_REQUESTS; i += 1) {
              const baseProgress = Math.round((i / PING_REQUESTS) * 100);
              postMessage({ type: 'progress', payload: { phase: 'ping', progress: baseProgress, samples: samples.length, instantValue: samples[samples.length - 1] || 0, averageValue: average(samples) } });
              try {
                const duration = await retry(() => measureLatency(PING_ENDPOINT));
                samples.push(duration);
                const avg = average(samples);
                const progress = Math.round(((i + 1) / PING_REQUESTS) * 100);
                postMessage({ type: 'progress', payload: { phase: 'ping', progress, samples: samples.length, instantValue: duration, averageValue: avg } });
              } catch (error) {
                console.warn('Ping sample failed', error);
              }
            }
            if (!samples.length) {
              const err = new Error('Unable to determine latency. Check your connection.');
              err.phase = 'ping';
              throw err;
            }
            const pingAverage = average(samples);
            const jitter = calculateJitter(samples);
            postMessage({ type: 'phase', payload: { phase: 'ping', status: 'Complete', progress: 100 } });
            return { average: pingAverage, jitter, min: Math.min(...samples), max: Math.max(...samples), count: samples.length };
          }

          async function runDownloadTest() {
            postMessage({ type: 'phase', payload: { phase: 'download', status: 'Testing…', progress: 0 } });
            const metrics = { bytes: 0, duration: 0, samples: 0 };
            const startTime = performance.now();
            const totalTasks = DOWNLOAD_SIZES.length * DOWNLOAD_CONCURRENCY;
            const tasks = [];
            for (let i = 0; i < DOWNLOAD_SIZES.length; i += 1) {
              for (let c = 0; c < DOWNLOAD_CONCURRENCY; c += 1) {
                const size = DOWNLOAD_SIZES[i];
                tasks.push((async () => {
                  const result = await downloadSample(size);
                  metrics.bytes += result.bytes;
                  metrics.duration += result.duration;
                  metrics.samples += 1;
                  const elapsed = performance.now() - startTime;
                  const averageMbps = bitsPerSecond(metrics.bytes, metrics.duration);
                  const instantMbps = bitsPerSecond(result.bytes, result.duration);
                  const progress = Math.min(100, Math.max(Math.round((elapsed / DOWNLOAD_TARGET_DURATION) * 100), Math.round((metrics.samples / totalTasks) * 100)));
                  postMessage({ type: 'progress', payload: { phase: 'download', progress, instantValue: instantMbps, averageValue: averageMbps } });
                })().catch(error => {
                  const err = error instanceof Error ? error : new Error(String(error));
                  err.phase = err.phase || 'download';
                  throw err;
                }));
              }
            }
            try {
              await Promise.all(tasks);
            } catch (error) {
              const err = error instanceof Error ? error : new Error(String(error));
              err.phase = err.phase || 'download';
              throw err;
            }
            const totalDuration = (performance.now() - startTime) / 1000;
            const averageMbps = bitsPerSecond(metrics.bytes, metrics.duration);
            const sustainedMbps = totalDuration > 0 ? (metrics.bytes * 8) / (totalDuration * 1e6) : averageMbps;
            postMessage({ type: 'phase', payload: { phase: 'download', status: 'Complete', progress: 100 } });
            return { averageMbps: Math.max(averageMbps, sustainedMbps), samples: metrics.samples };
          }

          async function runUploadTest() {
            postMessage({ type: 'phase', payload: { phase: 'upload', status: 'Testing…', progress: 0 } });
            const metrics = { bytes: 0, duration: 0, samples: 0 };
            const startTime = performance.now();
            const totalTasks = UPLOAD_SIZES.length * UPLOAD_CONCURRENCY;
            const tasks = [];
            for (let i = 0; i < UPLOAD_SIZES.length; i += 1) {
              for (let c = 0; c < UPLOAD_CONCURRENCY; c += 1) {
                const size = UPLOAD_SIZES[i];
                tasks.push((async () => {
                  const result = await uploadSample(size);
                  metrics.bytes += result.bytes;
                  metrics.duration += result.duration;
                  metrics.samples += 1;
                  const elapsed = performance.now() - startTime;
                  const averageMbps = bitsPerSecond(metrics.bytes, metrics.duration);
                  const instantMbps = bitsPerSecond(result.bytes, result.duration);
                  const progress = Math.min(100, Math.max(Math.round((elapsed / UPLOAD_TARGET_DURATION) * 100), Math.round((metrics.samples / totalTasks) * 100)));
                  postMessage({ type: 'progress', payload: { phase: 'upload', progress, instantValue: instantMbps, averageValue: averageMbps } });
                })().catch(error => {
                  const err = error instanceof Error ? error : new Error(String(error));
                  err.phase = err.phase || 'upload';
                  throw err;
                }));
              }
            }
            try {
              await Promise.all(tasks);
            } catch (error) {
              const err = error instanceof Error ? error : new Error(String(error));
              err.phase = err.phase || 'upload';
              throw err;
            }
            const totalDuration = (performance.now() - startTime) / 1000;
            const averageMbps = bitsPerSecond(metrics.bytes, metrics.duration);
            const sustainedMbps = totalDuration > 0 ? (metrics.bytes * 8) / (totalDuration * 1e6) : averageMbps;
            postMessage({ type: 'phase', payload: { phase: 'upload', status: 'Complete', progress: 100 } });
            return { averageMbps: Math.max(averageMbps, sustainedMbps), samples: metrics.samples };
          }

          async function downloadSample(size) {
            let attempt = 0;
            while (attempt < MAX_ATTEMPTS) {
              attempt += 1;
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), TEST_TIMEOUT_MS);
              const url = \`https://speed.cloudflare.com/__down?bytes=\${size}&r=\${Math.random()}\`;
              const started = performance.now();
              try {
                const response = await fetch(url, { cache: 'no-store', signal: controller.signal });
                if (!response.ok) throw new Error('Download failed with status ' + response.status);
                if (!response.body || !response.body.getReader) {
                  const buffer = await response.arrayBuffer();
                  const finished = performance.now();
                  return { bytes: buffer.byteLength, duration: (finished - started) / 1000 };
                }
                const reader = response.body.getReader();
                let received = 0;
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) break;
                  received += value.byteLength;
                }
                const finished = performance.now();
                return { bytes: received, duration: (finished - started) / 1000 };
              } catch (error) {
                if (attempt >= MAX_ATTEMPTS) {
                  const err = error instanceof Error ? error : new Error(String(error));
                  err.phase = 'download';
                  throw err;
                }
                await sleep(BACKOFF_MS * attempt);
              } finally {
                clearTimeout(timeoutId);
              }
            }
            const err = new Error('Download failed after retries');
            err.phase = 'download';
            throw err;
          }

          async function uploadSample(size) {
            let attempt = 0;
            while (attempt < MAX_ATTEMPTS) {
              attempt += 1;
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), TEST_TIMEOUT_MS);
              const payload = new Uint8Array(size);
              crypto.getRandomValues(payload);
              const started = performance.now();
              try {
                const response = await fetch('https://httpbin.org/post', {
                  method: 'POST',
                  body: payload,
                  signal: controller.signal,
                  headers: { 'Content-Type': 'application/octet-stream' },
                  cache: 'no-store',
                });
                if (!response.ok) throw new Error('Upload failed with status ' + response.status);
                const finished = performance.now();
                return { bytes: size, duration: (finished - started) / 1000 };
              } catch (error) {
                if (attempt >= MAX_ATTEMPTS) {
                  const err = error instanceof Error ? error : new Error(String(error));
                  err.phase = 'upload';
                  throw err;
                }
                await sleep(BACKOFF_MS * attempt);
              } finally {
                clearTimeout(timeoutId);
              }
            }
            const err = new Error('Upload failed after retries');
            err.phase = 'upload';
            throw err;
          }

          async function measureLatency(url) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), TEST_TIMEOUT_MS);
            const started = performance.now();
            try {
              const response = await fetch(url, { method: 'GET', cache: 'no-store', signal: controller.signal });
              if (!response.ok) throw new Error('Ping failed with status ' + response.status);
              const finished = performance.now();
              return finished - started;
            } finally {
              clearTimeout(timeoutId);
            }
          }

          function average(list) {
            if (!list.length) return 0;
            return list.reduce((sum, value) => sum + value, 0) / list.length;
          }

          function calculateJitter(samples) {
            if (samples.length < 2) return 0;
            let totalDiff = 0;
            for (let i = 1; i < samples.length; i += 1) {
              totalDiff += Math.abs(samples[i] - samples[i - 1]);
            }
            return totalDiff / (samples.length - 1);
          }

          function bitsPerSecond(bytes, durationSeconds) {
            if (!durationSeconds) return 0;
            return (bytes * 8) / (durationSeconds * 1e6);
          }

          function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
          }

          async function retry(fn, attempts = MAX_ATTEMPTS) {
            let lastError;
            for (let attempt = 1; attempt <= attempts; attempt += 1) {
              try {
                return await fn(attempt);
              } catch (error) {
                lastError = error;
                if (attempt < attempts) {
                  await sleep(BACKOFF_MS * attempt);
                }
              }
            }
            throw lastError;
          }
        })();`;

        const blob = new Blob([workerScript], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
      }

      function startTest() {
        if (!window.Worker) {
          showToast('Unsupported', 'Web Workers are not supported in this browser.');
          return;
        }
        if (worker) {
          showToast('In progress', 'A test is already running.');
          return;
        }
        resetMetrics();
        resetGauge();
        setGaugePhase('Ping', 'ms', MAX_PING);
        updateGaugeTarget(0);
        ui.startButton.disabled = true;
        ui.startButton.textContent = 'Testing…';
        showToast('Starting test', 'Running ping, download, and upload diagnostics…', 3000);
        worker = createWorker();
        worker.onmessage = handleWorkerMessage;
        worker.onerror = (error) => {
          console.error('Worker error', error);
          handleError({ message: 'Speed test worker error. See console.' });
        };
        worker.postMessage({ type: 'start' });
      }

      function copyResultsToClipboard() {
        if (!latestResults) {
          showToast('Nothing to copy', 'Run a test before copying results.');
          return;
        }
        if (!navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {
          showToast('Clipboard unavailable', 'Your browser does not permit copying automatically.');
          return;
        }
        const text = `TestDebit Results\nPing: ${formatNumber(latestResults.pingMs, 2)} ms\nJitter: ${formatNumber(latestResults.jitterMs, 2)} ms\nDownload: ${formatNumber(latestResults.downloadMbps, 2)} Mbps\nUpload: ${formatNumber(latestResults.uploadMbps, 2)} Mbps\nRecorded: ${new Date(latestResults.timestamp).toLocaleString()}`;
        navigator.clipboard.writeText(text).then(() => {
          showToast('Copied', 'Results copied to clipboard.');
        }).catch(error => {
          console.error('Clipboard copy failed', error);
          showToast('Clipboard blocked', 'Unable to copy results automatically.');
        });
      }

      function toggleTheme() {
        const current = document.documentElement.getAttribute('data-theme');
        const next = current === 'dark' ? 'light' : 'dark';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem(THEME_KEY, next);
      }

      function initThemeToggle() {
        ui.themeToggle.addEventListener('click', toggleTheme, { passive: true });
      }

      function initEventListeners() {
        ui.startButton.addEventListener('click', startTest);
        ui.testAgain.addEventListener('click', startTest);
        ui.copyResults.addEventListener('click', copyResultsToClipboard);
        window.addEventListener('beforeunload', terminateWorker);
      }

      function init() {
        document.getElementById('year').textContent = new Date().getFullYear().toString();
        renderHistory();
        initEventListeners();
        initThemeToggle();
        resetGauge();
        fetchConnectionInfo();
      }

      init();
    })();
  </script>
</body>
</html>
